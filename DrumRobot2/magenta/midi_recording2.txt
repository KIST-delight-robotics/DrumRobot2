import mido
import pretty_midi
import note_seq
from mido import MidiFile, MidiTrack, Message
import time
import datetime

# ====================================================
# [디버깅용 출력 함수들은 변경 없이 유지]
# ====================================================
def print_midi_mido(midi_path):
    midi_file = mido.MidiFile(midi_path)
    for i, track in enumerate(midi_file.tracks):
        print(f"Track {i}: {track.name}")
        for msg in track:
            print(msg)

def print_midi_pretty_midi(midi_path):
    midi_data = pretty_midi.PrettyMIDI(midi_path)
    print(f"Resolution (Ticks per Quarter): {midi_data.resolution}")
    tempo, _ = midi_data.get_tempo_changes()
    print(f"Tempo: {tempo}")
    num_notes = 0
    for instrument in midi_data.instruments:
        num_notes += len(instrument.notes)
        print(f"Instrument: {instrument.program}, Number of Notes: {len(instrument.notes)}")
        for note in instrument.notes:
            print(f"Pitch: {note.pitch}, Start: {note.start}, End: {note.end}")
    print(f"Total Number of Notes: {num_notes}")

def print_midi_sequence(midi_path):
    input_sequence = note_seq.midi_file_to_sequence_proto(midi_path)
    for note in input_sequence.notes:
        print(f"Pitch: {note.pitch}, Start Time: {note.start_time}, End Time: {note.end_time}, Is Drum: {note.is_drum}")


# ====================================================
# [수정됨] RecordingManager 클래스
# Raw MIDI Interface를 사용하도록 로직 변경
# ====================================================
class RecordingManager:
    # [수정 1] __init__에서 input_port_name 대신 midi_interface 객체를 받음
    def __init__(self, midi_interface, bpm=120, base_path=None):
        self.bpm = bpm
        self.midi_interface = midi_interface  # 객체 저장
        self.base_path = base_path
        print(f"\n[Python] RecordingManager Initialized (Raw MIDI Mode)")

    def print_device_name(self):
        # Raw MIDI 모드에서는 장치 이름을 조회할 수 없으므로 패스하거나 고정 출력
        print("[Python] Device: Raw MIDI Interface (/dev/snd/midiC2D0)")

    # [수정 2] MIDI 입력 버퍼 비우기 (인터페이스의 이벤트를 소모)
    def clear_input_buffer(self, wait_second=3):
        print("\n[Python] Clearing input buffer...")
        print(f"[Python] Waiting for {wait_second} seconds.")
        
        start = time.time()
        cnt_second = 1
        
        while time.time() < start + wait_second:
            # 쌓여있는 이벤트를 가져와서 버림 (Flush)
            _ = self.midi_interface.get_event()

            if time.time() > start + cnt_second:
                print(f"[Python] {wait_second - cnt_second}")
                cnt_second = cnt_second + 1

            time.sleep(0.01)

    def make_sync_file(self):
        current_time = datetime.datetime.now().strftime("%H:%M:%S.%f")[:-3]
        
        if self.base_path is None:
            path = "sync/sync.txt"
        else:
            path = self.base_path + "sync/sync.txt"
            
        with open(path, "w") as f:
            f.write(current_time)

    # [수정 3] 첫 타격 감지 로직 변경
    def detect_first_hit(self):
        bpm = self.bpm
        ticks_per_beat = 480
        
        # mido.open_input 삭제됨 -> self.midi_interface 사용

        mid = MidiFile(ticks_per_beat=ticks_per_beat)
        track = MidiTrack()
        mid.tracks.append(track)

        track.append(mido.MetaMessage('track_name', name='Drum Track'))
        track.append(mido.MetaMessage('set_tempo', tempo=mido.bpm2tempo(bpm)))
        track.append(mido.MetaMessage('time_signature', numerator=4, denominator=4))
        track.append(Message('program_change', channel=9, program=0, time=0))
        
        self.clear_input_buffer(wait_second=1) # 기본 대기 1초
        
        first_note_received = False
        print("[Python] Waiting for the first hit...")

        while True:
            # [핵심 변경] iter_pending 대신 get_event 사용
            msg = self.midi_interface.get_event()

            if msg:
                if msg.type == 'note_on' and not first_note_received:
                    first_note_received = True
                    print("\n[Python] First note received, make sync file")
                    self.make_sync_file()

            if first_note_received:
                break
            
            # CPU 과점유 방지
            time.sleep(0.001)
        
        # midi_input.close() 삭제 (인터페이스는 계속 살아있어야 함)

    # [수정 4] record_for_time 로직 변경
    def record_for_time(self, output_file, buffer_clear_flag=False):
        bpm = self.bpm
        ticks_per_beat = 480
        seconds_per_beat = 60 / bpm
        recording_second = 8 * seconds_per_beat
        
        mid = MidiFile(ticks_per_beat=ticks_per_beat)
        track = MidiTrack()
        mid.tracks.append(track)

        track.append(mido.MetaMessage('track_name', name='Drum Track'))
        track.append(mido.MetaMessage('set_tempo', tempo=mido.bpm2tempo(bpm)))
        track.append(mido.MetaMessage('time_signature', numerator=4, denominator=4))
        track.append(Message('program_change', channel=9, program=0, time=0))
        
        if buffer_clear_flag:
            self.clear_input_buffer()

        print(f"\n[Python] Recording for {recording_second} seconds...")
        
        start_time = time.time()
        last_message_time = time.time()

        while True:
            # [핵심 변경] 메시지 수신 방식 변경
            msg = self.midi_interface.get_event()

            if msg:
                print(f"[Python] Recording - Message Received: {msg}")

                now = time.time()
                time_since_last_message = now - last_message_time
                ticks_since_last_message = time_since_last_message / seconds_per_beat * ticks_per_beat
                t = int(ticks_since_last_message)

                if msg.type == 'note_on':
                    track.append(Message('note_on', channel=9, note=msg.note, velocity=msg.velocity, time=t))
                    last_message_time = time.time()
                elif msg.type == 'note_off':
                    track.append(Message('note_on', channel=9, note=msg.note, velocity=0, time=t))
                    last_message_time = time.time()
                        
            elapsed_time = time.time() - start_time
            if elapsed_time >= recording_second:
                print(f"[Python] Recording stopped after {recording_second} seconds.")
                break
                
            time.sleep(0.001) # 0.01 -> 0.001로 단축 (반응성 향상)
        
        track.append(mido.MetaMessage('end_of_track', time=1))
        mid.save(output_file)
        print(f"\n[Python] Recording saved to {output_file}")
        # midi_input.close() 삭제

    # [수정 5] record_after_first_hit 로직 변경
    def record_after_first_hit(self, output_file, wait_second, sample_i):
        bpm = self.bpm
        ticks_per_beat = 480
        seconds_per_beat = 60 / bpm
        recording_second = 8 * seconds_per_beat
        
        mid = MidiFile(ticks_per_beat=ticks_per_beat)
        track = MidiTrack()
        mid.tracks.append(track)

        track.append(mido.MetaMessage('track_name', name='Drum Track'))
        track.append(mido.MetaMessage('set_tempo', tempo=mido.bpm2tempo(bpm)))
        track.append(mido.MetaMessage('time_signature', numerator=4, denominator=4))
        track.append(Message('program_change', channel=9, program=0, time=0))
        
        self.clear_input_buffer(wait_second)

        print(f"\n[Python] Recording for {recording_second} seconds after the first note...")
        
        first_note_received = False
        start_time = None
        last_message_time = None

        while True:
            # [핵심 변경] 메시지 수신
            msg = self.midi_interface.get_event()
            
            # 메시지가 있을 때 처리
            if msg:
                print(f"[Python] Recording - Message Received: {msg}")

                if msg.type == 'note_on' and not first_note_received:
                    first_note_received = True

                    # [특수 로직 유지] sample_i에 따른 버퍼 비우기
                    if sample_i == 0:
                        self.clear_input_buffer(15) 
                    if sample_i == 2:
                        self.clear_input_buffer(10)

                    start_time = time.time()
                    last_message_time = time.time()
                    t = 0
                    print("[Python] First note received, starting recording...")
                    self.make_sync_file()
                
                elif first_note_received:
                    now = time.time()
                    time_since_last_message = now - last_message_time
                    ticks_since_last_message = time_since_last_message / seconds_per_beat * ticks_per_beat
                    t = int(ticks_since_last_message)
                    
                    if msg.type == 'note_on':
                        track.append(Message('note_on', channel=9, note=msg.note, velocity=msg.velocity, time=t))
                        last_message_time = time.time()
                    elif msg.type == 'note_off':
                        track.append(Message('note_on', channel=9, note=msg.note, velocity=0, time=t))
                        last_message_time = time.time()

            # 시간 체크 및 탈출 조건
            if first_note_received:
                elapsed_time = time.time() - start_time
                if elapsed_time >= recording_second:
                    print(f"[Python] Recording stopped after {recording_second} seconds.")
                    break
                
            time.sleep(0.001) # 반응성 향상
        
        track.append(mido.MetaMessage('end_of_track', time=1))
        mid.save(output_file)
        print(f"\n[Python] Recording saved to {output_file}")
        # midi_input.close() 삭제